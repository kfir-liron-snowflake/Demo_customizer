import streamlit as st
import streamlit.components.v1 as components
import json
import uuid

# Initialize session state
if 'nodes' not in st.session_state:
    st.session_state.nodes = []
if 'edges' not in st.session_state:
    st.session_state.edges = []
if 'node_counter' not in st.session_state:
    st.session_state.node_counter = 0
if 'selected_connection' not in st.session_state:
    st.session_state.selected_connection = {'from': None, 'to': None}

# Page configuration - Ensure wide layout
st.set_page_config(
    page_title="Visual Pipeline Builder", 
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("üîß Visual Pipeline Builder")
st.subheader("Build Your Data Pipeline Visually")

# Sidebar for controls
with st.sidebar:
    st.header("üì¶ Pipeline Controls")
    
    # Component types
    component_types = {
        "Data Source": {"color": "#4CAF50", "icon": "üóÉÔ∏è"},
        "Transform": {"color": "#2196F3", "icon": "‚öôÔ∏è"},
        "Filter": {"color": "#FF9800", "icon": "üîç"},
        "Aggregate": {"color": "#9C27B0", "icon": "üìä"},
        "Output": {"color": "#F44336", "icon": "üíæ"}
    }
    
    st.markdown("### Add Components")
    
    # Create buttons for each component type
    for comp_type, style in component_types.items():
        if st.button(f"{style['icon']} Add {comp_type}", key=f"add_{comp_type}"):
            st.session_state.node_counter += 1
            new_node = {
                'id': f"node_{st.session_state.node_counter}",
                'label': f"{comp_type} #{st.session_state.node_counter}",
                'type': comp_type,
                'color': style['color'],
                'x': 100 + (st.session_state.node_counter * 30),
                'y': 100 + (st.session_state.node_counter * 30)
            }
            st.session_state.nodes.append(new_node)
            st.rerun()
    
    st.markdown("---")
    
    # Connection controls
    st.markdown("### Connect Nodes")
    
    if len(st.session_state.nodes) >= 2:
        node_options = {f"{node['label']} ({node['id']})": node['id'] for node in st.session_state.nodes}
        
        from_node = st.selectbox("From Node:", list(node_options.keys()), key="from_node")
        to_node = st.selectbox("To Node:", list(node_options.keys()), key="to_node")
        
        if st.button("üîó Connect Nodes"):
            from_id = node_options[from_node]
            to_id = node_options[to_node]
            
            if from_id != to_id:
                # Check if connection already exists
                existing = any(edge['from'] == from_id and edge['to'] == to_id 
                             for edge in st.session_state.edges)
                if not existing:
                    new_edge = {
                        'id': f"{from_id}_to_{to_id}",
                        'from': from_id,
                        'to': to_id
                    }
                    st.session_state.edges.append(new_edge)
                    st.rerun()
                else:
                    st.warning("Connection already exists!")
            else:
                st.warning("Cannot connect a node to itself!")
    else:
        st.info("Add at least 2 nodes to create connections")
    
    st.markdown("---")
    
    # Pipeline management
    st.markdown("### Pipeline Management")
    
    if st.button("üóëÔ∏è Clear All"):
        st.session_state.nodes = []
        st.session_state.edges = []
        st.session_state.node_counter = 0
        st.session_state.dragged_positions = {}
        st.rerun()
    
    if st.button("üîÑ Reset All Positions"):
        st.session_state.dragged_positions = {}
        st.success("All node positions reset to original locations!")
        st.rerun()
    
    if st.button("üíæ Export Pipeline"):
        if st.session_state.nodes:
            pipeline_data = {
                "nodes": st.session_state.nodes,
                "edges": st.session_state.edges,
                "metadata": {
                    "total_nodes": len(st.session_state.nodes),
                    "total_edges": len(st.session_state.edges),
                    "created": "now"
                }
            }
            st.success("Pipeline exported!")
            st.download_button(
                label="üìÑ Download JSON",
                data=json.dumps(pipeline_data, indent=2),
                file_name="pipeline.json",
                mime="application/json"
            )
        else:
            st.warning("No pipeline to export!")
    
    # Pipeline stats
    st.markdown("---")
    st.markdown("### Pipeline Stats")
    st.metric("Total Nodes", len(st.session_state.nodes))
    st.metric("Connections", len(st.session_state.edges))

# AGGRESSIVE CSS to override ALL possible Streamlit width constraints
st.markdown("""
<style>
    /* NUCLEAR OPTION: Override every possible Streamlit container */
    .main .block-container,
    .block-container,
    div[data-testid="stMainBlockContainer"],
    div[data-testid="block-container"],
    .main,
    section.main,
    .stApp .main,
    .css-18e3th9,
    .css-1d391kg,
    .css-12oz5g7,
    .css-1y4p8pa {
        max-width: none !important;
        width: 100% !important;
        padding-left: 1rem !important;
        padding-right: 1rem !important;
    }
    
    /* Force full viewport width */
    .stApp,
    [data-testid="stAppViewContainer"],
    [data-testid="stApp"] {
        max-width: 100vw !important;
        width: 100vw !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    
    /* Target ALL possible content containers */
    div[data-testid="stMarkdownContainer"],
    div[data-testid="stMarkdown"],
    .stMarkdown,
    .stHTML,
    div[class*="css-"],
    div[class*="block"],
    div[class*="container"] {
        max-width: none !important;
        width: 100% !important;
    }
    
    /* Canvas specific overrides */
    #pipeline-canvas-container {
        width: 100vw !important;
        max-width: calc(100vw - 20rem) !important; /* Account for sidebar */
        margin: 0 !important;
        padding: 0 !important;
        position: relative !important;
        left: 0 !important;
    }
    
    #pipeline-canvas {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 800px !important;
        box-sizing: border-box !important;
    }
    
    /* Override iframe constraints */
    iframe,
    .stComponentsIframe iframe {
        width: 100% !important;
        max-width: 100% !important;
    }
    
    /* Remove any overflow hidden that might crop content */
    * {
        overflow-x: visible !important;
    }
    
    /* Ensure text is not cropped */
    h1, h2, h3, p, div {
        white-space: normal !important;
        overflow: visible !important;
        text-overflow: clip !important;
    }
</style>
""", unsafe_allow_html=True)

# Use wide container for maximum width utilization  
with st.container():
    st.markdown("### üé® Pipeline Canvas")
    
    # Add session state for node positions if dragged
    if 'dragged_positions' not in st.session_state:
        st.session_state.dragged_positions = {}

    # Custom HTML/CSS/JS for the canvas with drag functionality
    canvas_html = f"""
<div id="pipeline-canvas-container">
    <div id="pipeline-canvas" style="
        width: 100%; 
        height: 600px; 
        border: 2px dashed #ccc; 
        position: relative; 
        background: linear-gradient(90deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 10px;
        overflow: hidden;
        min-width: 800px;
        max-width: 100%;
        box-sizing: border-box;
    ">
    <div style="
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        text-align: center; 
        color: #6c757d;
        font-size: 18px;
    " id="canvas-message">
        {'üëà Add components from the sidebar to start building!' if not st.session_state.nodes else ''}
    </div>
    
    <!-- SVG for connections -->
    <svg id="connections-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 1;">
        {chr(10).join([f'''
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
            </marker>
        </defs>
        ''' if st.session_state.edges else ''])}
        
            {chr(10).join([f'''
            <line id="edge_{edge['id']}" 
                  x1="{st.session_state.dragged_positions.get(edge['from'], {}).get('x', next((n['x'] for n in st.session_state.nodes if n['id'] == edge['from']), 0)) + 60}" 
                  y1="{st.session_state.dragged_positions.get(edge['from'], {}).get('y', next((n['y'] for n in st.session_state.nodes if n['id'] == edge['from']), 0)) + 30}" 
                  x2="{st.session_state.dragged_positions.get(edge['to'], {}).get('x', next((n['x'] for n in st.session_state.nodes if n['id'] == edge['to']), 0))}" 
                  y2="{st.session_state.dragged_positions.get(edge['to'], {}).get('y', next((n['y'] for n in st.session_state.nodes if n['id'] == edge['to']), 0)) + 30}" 
                  stroke="#666" stroke-width="2" marker-end="url(#arrowhead)" />
            ''' for edge in st.session_state.edges])}
    </svg>
    
        <!-- Nodes -->
        {chr(10).join([f'''
    <div id="{node['id']}" 
         class="draggable-node" 
         style="
        position: absolute;
        left: {st.session_state.dragged_positions.get(node['id'], {}).get('x', node['x'])}px;
        top: {st.session_state.dragged_positions.get(node['id'], {}).get('y', node['y'])}px;
        width: 120px;
        height: 60px;
        background: {node['color']};
        color: white;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        cursor: move;
        z-index: 2;
        border: 2px solid rgba(255,255,255,0.3);
        user-select: none;
        transition: box-shadow 0.2s ease;
    " 
    onmousedown="startDrag(event, '{node['id']}')"
    title="{node['label']} - Drag to move"
    >
        {node['label']}
    </div>
    ''' for node in st.session_state.nodes])}

    <!-- Hidden inputs to store node positions -->
    {chr(10).join([f'''
    <input type="hidden" id="pos_{node['id']}_x" value="{st.session_state.dragged_positions.get(node['id'], {}).get('x', node['x'])}" />
    <input type="hidden" id="pos_{node['id']}_y" value="{st.session_state.dragged_positions.get(node['id'], {}).get('y', node['y'])}" />
    ''' for node in st.session_state.nodes])}
</div>
</div>

<script>
    let isDragging = false;
    let currentNode = null;
    let startX, startY;
    let nodeStartX, nodeStartY;

    function startDrag(e, nodeId) {{
        e.preventDefault();
        isDragging = true;
        currentNode = document.getElementById(nodeId);
        
        // Get initial mouse position
        startX = e.clientX;
        startY = e.clientY;
        
        // Get initial node position
        nodeStartX = parseInt(currentNode.style.left);
        nodeStartY = parseInt(currentNode.style.top);
        
        // Add visual feedback
        currentNode.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';
        currentNode.style.transform = 'scale(1.05)';
        
        // Add event listeners
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
    }}

    function drag(e) {{
        if (!isDragging || !currentNode) return;
        
        e.preventDefault();
        
        // Calculate new position
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newX = nodeStartX + deltaX;
        let newY = nodeStartY + deltaY;
        
        // Keep node within canvas bounds
        const canvas = document.getElementById('pipeline-canvas');
        const canvasRect = canvas.getBoundingClientRect();
        
        newX = Math.max(0, Math.min(newX, canvasRect.width - 120));
        newY = Math.max(0, Math.min(newY, canvasRect.height - 60));
        
        // Update node position
        currentNode.style.left = newX + 'px';
        currentNode.style.top = newY + 'px';
        
        // Store position in localStorage for persistence
        localStorage.setItem(`pos_${{currentNode.id}}_x`, newX);
        localStorage.setItem(`pos_${{currentNode.id}}_y`, newY);
        
        // Update hidden inputs
        const xInput = document.getElementById(`pos_${{currentNode.id}}_x`);
        const yInput = document.getElementById(`pos_${{currentNode.id}}_y`);
        if (xInput) xInput.value = newX;
        if (yInput) yInput.value = newY;
        
        // Update connections
        updateConnections();
    }}

    function stopDrag(e) {{
        if (!isDragging || !currentNode) return;
        
        isDragging = false;
        
        // Remove visual feedback
        currentNode.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
        currentNode.style.transform = 'scale(1)';
        
        // Get final position
        const finalX = parseInt(currentNode.style.left);
        const finalY = parseInt(currentNode.style.top);
        
        // Store in localStorage for persistence across re-renders
        localStorage.setItem(`pos_${{currentNode.id}}_x`, finalX);
        localStorage.setItem(`pos_${{currentNode.id}}_y`, finalY);
        
        currentNode = null;
        
        // Remove event listeners
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
    }}
    
    // On page load, restore positions from localStorage
    window.addEventListener('load', function() {{
        const nodes = {json.dumps([node['id'] for node in st.session_state.nodes])};
        nodes.forEach(nodeId => {{
            const storedX = localStorage.getItem(`pos_${{nodeId}}_x`);
            const storedY = localStorage.getItem(`pos_${{nodeId}}_y`);
            
            if (storedX && storedY) {{
                const node = document.getElementById(nodeId);
                const xInput = document.getElementById(`pos_${{nodeId}}_x`);
                const yInput = document.getElementById(`pos_${{nodeId}}_y`);
                
                if (node) {{
                    node.style.left = storedX + 'px';
                    node.style.top = storedY + 'px';
                }}
                if (xInput) xInput.value = storedX;
                if (yInput) yInput.value = storedY;
            }}
        }});
        
        // Update connections after restoring positions
        setTimeout(updateConnections, 100);
    }});

    function updateConnections() {{
        // Update all connection lines when nodes are moved
        const edges = {json.dumps(st.session_state.edges)};
        const nodes = {json.dumps(st.session_state.nodes)};
        
        edges.forEach(edge => {{
            const line = document.getElementById('edge_' + edge.id);
            if (line) {{
                const fromNode = document.getElementById(edge.from);
                const toNode = document.getElementById(edge.to);
                
                if (fromNode && toNode) {{
                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const canvasRect = document.getElementById('pipeline-canvas').getBoundingClientRect();
                    
                    const x1 = fromRect.left - canvasRect.left + 60;
                    const y1 = fromRect.top - canvasRect.top + 30;
                    const x2 = toRect.left - canvasRect.left;
                    const y2 = toRect.top - canvasRect.top + 30;
                    
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                }}
            }}
        }});
    }}
    
    // Prevent text selection during drag
    document.addEventListener('selectstart', function(e) {{
        if (isDragging) e.preventDefault();
    }});
</script>
"""

    components.html(canvas_html, height=620)

# AGGRESSIVE JavaScript to force full width after page load
st.markdown("""
<script>
function forceFullWidth() {
    console.log('Forcing full width...');
    
    // Target all possible Streamlit containers
    const selectors = [
        '.main .block-container',
        '.block-container', 
        '[data-testid="stMainBlockContainer"]',
        '.main',
        'section.main',
        '.stApp .main',
        '.css-18e3th9',
        '.css-1d391kg', 
        '.css-12oz5g7',
        '.css-1y4p8pa',
        '[data-testid="stMarkdownContainer"]',
        '.stMarkdown',
        '.stHTML'
    ];
    
    selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.style.maxWidth = 'none';
            el.style.width = '100%';
            console.log('Applied width override to:', selector);
        });
    });
    
    // Force canvas container to be full width
    const canvasContainer = document.getElementById('pipeline-canvas-container');
    const canvas = document.getElementById('pipeline-canvas');
    
    if (canvasContainer) {
        // Calculate available width (viewport minus sidebar)
        const sidebarWidth = document.querySelector('.css-1d391kg')?.offsetWidth || 300;
        const availableWidth = window.innerWidth - sidebarWidth - 40;
        
        canvasContainer.style.width = availableWidth + 'px';
        canvasContainer.style.maxWidth = availableWidth + 'px';
        console.log('Canvas container width set to:', availableWidth);
        
        if (canvas) {
            canvas.style.width = '100%';
            canvas.style.maxWidth = '100%';
            console.log('Canvas width set to 100%');
        }
    }
    
    // Also check for text truncation and fix
    const textElements = document.querySelectorAll('h1, h2, h3, p, div, span');
    textElements.forEach(el => {
        if (el.style.textOverflow === 'ellipsis') {
            el.style.textOverflow = 'clip';
            el.style.whiteSpace = 'normal';
            el.style.overflow = 'visible';
        }
    });
}

// Run multiple times to ensure it works
window.addEventListener('load', function() {
    forceFullWidth();
    setTimeout(forceFullWidth, 100);
    setTimeout(forceFullWidth, 500);
    setTimeout(forceFullWidth, 1000);
    setTimeout(forceFullWidth, 2000);
});

// Also run on window resize
window.addEventListener('resize', forceFullWidth);

// Monitor for Streamlit updates and reapply
const observer = new MutationObserver(function(mutations) {
    let shouldUpdate = false;
    mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            shouldUpdate = true;
        }
    });
    if (shouldUpdate) {
        setTimeout(forceFullWidth, 100);
    }
});

// Start observing
setTimeout(() => {
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}, 1000);
</script>
""", unsafe_allow_html=True)


# Pipeline Overview - Now below the canvas
st.markdown("---")
st.markdown("### üìã Pipeline Overview")

if st.session_state.nodes:
    # Create columns for better organization of overview content
    col_nodes, col_connections = st.columns([1, 1])
    
    with col_nodes:
        st.markdown("**Nodes:**")
        for i, node in enumerate(st.session_state.nodes, 1):
            # Get current position (dragged or original)
            current_x = st.session_state.dragged_positions.get(node['id'], {}).get('x', node['x'])
            current_y = st.session_state.dragged_positions.get(node['id'], {}).get('y', node['y'])
            
            with st.expander(f"{i}. {node['label']}", expanded=False):
                st.write(f"**ID:** {node['id']}")
                st.write(f"**Type:** {node['type']}")
                st.write(f"**Position:** ({current_x}, {current_y})")
                if st.session_state.dragged_positions.get(node['id']):
                    st.info("üñ±Ô∏è Position modified by dragging")
                
                # Action buttons for each node  
                col_del, col_reset = st.columns(2)
                with col_del:
                    if st.button(f"‚ùå Delete", key=f"delete_{node['id']}"):
                        # Remove node and its dragged position
                        st.session_state.nodes = [n for n in st.session_state.nodes if n['id'] != node['id']]
                        # Remove associated edges
                        st.session_state.edges = [e for e in st.session_state.edges 
                                                if e['from'] != node['id'] and e['to'] != node['id']]
                        # Remove dragged position
                        if node['id'] in st.session_state.dragged_positions:
                            del st.session_state.dragged_positions[node['id']]
                        st.rerun()
                
                with col_reset:
                    if st.button(f"üîÑ Reset Pos", key=f"reset_{node['id']}"):
                        # Reset node position to original
                        if node['id'] in st.session_state.dragged_positions:
                            del st.session_state.dragged_positions[node['id']]
                        st.rerun()
    
    with col_connections:
        if st.session_state.edges:
            st.markdown("**Connections:**")
            for edge in st.session_state.edges:
                from_node = next((n for n in st.session_state.nodes if n['id'] == edge['from']), None)
                to_node = next((n for n in st.session_state.nodes if n['id'] == edge['to']), None)
                
                if from_node and to_node:
                    st.write(f"üîó {from_node['label']} ‚Üí {to_node['label']}")
        else:
            st.info("No connections yet")
else:
    st.info("No components added yet")
    st.markdown("""
    **Getting Started:**
    1. üì¶ Add components using the sidebar
    2. üîó Connect nodes to create data flow  
    3. üíæ Export your pipeline when ready
    4. üñ±Ô∏è Drag nodes around the canvas to reposition them
    """)

# Footer
st.markdown("---")
st.markdown("### üöÄ Pipeline Execution Preview")

if st.session_state.nodes:
    execution_order = []
    
    # Simple topological sort for execution order
    # Start with nodes that have no incoming edges
    remaining_nodes = st.session_state.nodes.copy()
    remaining_edges = st.session_state.edges.copy()
    
    while remaining_nodes:
        # Find nodes with no incoming edges
        nodes_with_no_incoming = []
        for node in remaining_nodes:
            has_incoming = any(edge['to'] == node['id'] for edge in remaining_edges)
            if not has_incoming:
                nodes_with_no_incoming.append(node)
        
        if not nodes_with_no_incoming:
            # Circular dependency or isolated nodes
            nodes_with_no_incoming = remaining_nodes[:1]
        
        # Add to execution order
        for node in nodes_with_no_incoming:
            execution_order.append(node['label'])
            remaining_nodes.remove(node)
            # Remove edges from this node
            remaining_edges = [e for e in remaining_edges if e['from'] != node['id']]
    
    st.write("**Estimated Execution Order:**")
    for i, node_label in enumerate(execution_order, 1):
        st.write(f"{i}. {node_label}")
else:
    st.info("Build your pipeline to see execution order")

# Debug section
with st.expander("üîç Debug Info"):
    col_debug1, col_debug2 = st.columns(2)
    with col_debug1:
        st.write("**Nodes:**")
        st.json(st.session_state.nodes)
    with col_debug2:
        st.write("**Edges:**")
        st.json(st.session_state.edges)
